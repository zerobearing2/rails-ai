#!/usr/bin/env bash
# Rails AI Release Script
# Automates version bumping, changelog updates, tagging, and GitHub release creation

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print section header
print_section() {
  echo ""
  echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo -e "${BLUE}$1${NC}"
  echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo ""
}

# Print success message
print_success() {
  echo -e "${GREEN}âœ… $1${NC}"
}

# Print error message
print_error() {
  echo -e "${RED}âŒ $1${NC}"
}

# Print warning message
print_warning() {
  echo -e "${YELLOW}âš ï¸  $1${NC}"
}

# Print info message
print_info() {
  echo -e "${BLUE}â„¹ï¸  $1${NC}"
}

# Dry run mode flag
DRY_RUN=false
if [ "$1" = "--dry-run" ] || [ "$1" = "-n" ]; then
  DRY_RUN=true
fi

# Check if we're in the right directory
if [ ! -f "Gemfile" ]; then
  print_error "Gemfile not found. Please run this script from the project root."
  exit 1
fi

# Check if gh CLI is installed (skip in dry-run)
if [ "$DRY_RUN" = false ]; then
  if ! command -v gh &> /dev/null; then
    print_error "GitHub CLI (gh) not installed. Install: https://cli.github.com/"
    exit 1
  fi

  # Check if gh is authenticated
  if ! gh auth status &> /dev/null; then
    print_error "GitHub CLI not authenticated. Run: gh auth login"
    exit 1
  fi
fi

# Welcome message
echo ""
echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
echo -e "${BLUE}â•‘       Rails AI - Release Script          â•‘${NC}"
if [ "$DRY_RUN" = true ]; then
  echo -e "${YELLOW}â•‘              (DRY RUN MODE)               â•‘${NC}"
fi
echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo ""

# Check for uncommitted changes (skip in dry-run)
if [ "$DRY_RUN" = false ]; then
  if [ -n "$(git status --porcelain)" ]; then
    print_error "You have uncommitted changes. Please commit or stash them first."
    git status --short
    exit 1
  fi
fi

# Make sure we're on main/master branch (skip in dry-run)
CURRENT_BRANCH=$(git branch --show-current)
if [ "$DRY_RUN" = false ]; then
  if [ "$CURRENT_BRANCH" != "master" ] && [ "$CURRENT_BRANCH" != "main" ]; then
    print_warning "You're on branch '$CURRENT_BRANCH', not master/main"
    read -p "Continue anyway? (y/n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      print_info "Release cancelled"
      exit 1
    fi
  fi

  # Pull latest changes
  print_section "ğŸ“¥ Pulling Latest Changes"
  git pull origin $CURRENT_BRANCH
  print_success "Up to date with remote"
fi

# Run CI checks (skip in dry-run)
if [ "$DRY_RUN" = false ]; then
  print_section "ğŸ§ª Running CI Checks"
  print_info "Running bin/ci to ensure everything passes..."
  if ./bin/ci; then
    print_success "All CI checks passed"
  else
    print_error "CI checks failed. Fix issues before releasing."
    exit 1
  fi
fi

# Get current version from CHANGELOG
# Skip [Unreleased] and find first version number like [0.1.1]
CURRENT_VERSION=$(grep -oP '## \[\K[0-9]+\.[0-9]+\.[0-9]+' CHANGELOG.md | head -1)
if [ -z "$CURRENT_VERSION" ]; then
  print_warning "Could not detect current version from CHANGELOG.md"
  CURRENT_VERSION="0.0.0"
fi

print_info "Current version: $CURRENT_VERSION"

# Get last version tag
LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
if [ -z "$LAST_TAG" ]; then
  print_warning "No previous tags found"
  LAST_TAG="HEAD~10"  # Use last 10 commits if no tags
else
  print_info "Last tag: $LAST_TAG"
fi

# Ask for new version
print_section "ğŸ“ Version Bump"
echo "Current version: $CURRENT_VERSION"
echo ""
echo "Release type:"
echo "  1) Patch (bug fixes)         - e.g., 0.1.0 â†’ 0.1.1"
echo "  2) Minor (new features)      - e.g., 0.1.1 â†’ 0.2.0"
echo "  3) Major (breaking changes)  - e.g., 0.2.0 â†’ 1.0.0"
echo "  4) Custom version"
echo ""
read -p "Select release type (1-4): " RELEASE_TYPE

IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
MAJOR="${VERSION_PARTS[0]}"
MINOR="${VERSION_PARTS[1]}"
PATCH="${VERSION_PARTS[2]}"

case $RELEASE_TYPE in
  1)
    PATCH=$((PATCH + 1))
    NEW_VERSION="$MAJOR.$MINOR.$PATCH"
    ;;
  2)
    MINOR=$((MINOR + 1))
    PATCH=0
    NEW_VERSION="$MAJOR.$MINOR.$PATCH"
    ;;
  3)
    MAJOR=$((MAJOR + 1))
    MINOR=0
    PATCH=0
    NEW_VERSION="$MAJOR.$MINOR.$PATCH"
    ;;
  4)
    read -p "Enter custom version (e.g., 1.0.0): " NEW_VERSION
    if ! [[ $NEW_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
      print_error "Invalid version format. Must be X.Y.Z"
      exit 1
    fi
    ;;
  *)
    print_error "Invalid selection"
    exit 1
    ;;
esac

print_info "New version will be: $NEW_VERSION"

# Generate release notes using bin/changelog
print_section "ğŸ“‹ Generating Release Notes"
print_info "Running bin/changelog to generate release notes..."

# Run bin/changelog which will handle all the logic
if ./bin/changelog; then
  # Read the generated changelog entry from temp file
  CHANGELOG_TEMP_FILE="${TMPDIR:-/tmp}/rails-ai-changelog-entry.txt"
  if [ -f "$CHANGELOG_TEMP_FILE" ]; then
    RELEASE_NOTES=$(cat "$CHANGELOG_TEMP_FILE")
    print_success "Release notes generated successfully"
  else
    print_error "bin/changelog did not produce output file"
    exit 1
  fi
else
  print_error "bin/changelog failed"
  exit 1
fi

if [ -z "$RELEASE_NOTES" ]; then
  print_error "Release notes cannot be empty"
  exit 1
fi

# Confirm release
print_section "ğŸ” Review Release"
echo "Version: $NEW_VERSION"
echo ""
echo "Release Notes:"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "$RELEASE_NOTES"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

if [ "$DRY_RUN" = true ]; then
  print_warning "DRY RUN MODE - No changes made"
  echo ""
  print_info "What would happen:"
  echo "  1. Update CHANGELOG.md with version $NEW_VERSION"
  echo "  2. Update .claude-plugin/marketplace.json version to $NEW_VERSION"
  echo "  3. Commit changelog and plugin version with release notes"
  echo "  4. Create git tag v$NEW_VERSION"
  echo "  5. Push to origin/$CURRENT_BRANCH"
  echo "  6. Push tag v$NEW_VERSION"
  echo "  7. Create GitHub release"
  echo ""
  print_success "Dry run complete. Run without --dry-run to execute."
  exit 0
fi

read -p "Create this release? (y/n) " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
  print_info "Release cancelled"
  exit 1
fi

# Update CHANGELOG.md and plugin version
print_section "ğŸ“ Updating Version Files"
TODAY=$(date +%Y-%m-%d)

# Update CHANGELOG.md
print_info "Updating CHANGELOG.md..."

# Use awk instead of sed for reliable multi-line insertion
awk -v version="$NEW_VERSION" -v date="$TODAY" -v notes="$RELEASE_NOTES" '
/## \[Unreleased\]/ {
  print
  print ""
  print "## [" version "] - " date
  print ""
  print notes
  print ""
  next
}
{ print }
' CHANGELOG.md > CHANGELOG.md.tmp && mv CHANGELOG.md.tmp CHANGELOG.md

print_success "CHANGELOG.md updated"

# Update Claude plugin version in marketplace.json
if [ -f ".claude-plugin/marketplace.json" ]; then
  print_info "Updating .claude-plugin/marketplace.json..."

  # Use sed to update the version field in the JSON
  sed -i "s/\"version\": \"[0-9]*\.[0-9]*\.[0-9]*\"/\"version\": \"$NEW_VERSION\"/" .claude-plugin/marketplace.json

  print_success "Plugin version updated to $NEW_VERSION"
else
  print_warning ".claude-plugin/marketplace.json not found, skipping plugin version update"
fi

# Commit changelog and plugin version
print_info "Committing version changes..."
git add CHANGELOG.md
if [ -f ".claude-plugin/marketplace.json" ]; then
  git add .claude-plugin/marketplace.json
fi
git commit -m "Release $NEW_VERSION

$RELEASE_NOTES

ğŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"

print_success "Changelog committed"

# Create git tag
print_section "ğŸ·ï¸  Creating Git Tag"
git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION

$RELEASE_NOTES"
print_success "Tag v$NEW_VERSION created"

# Push to GitHub
print_section "ğŸ“¤ Pushing to GitHub"
print_info "Pushing commits and tags..."
git push origin $CURRENT_BRANCH
git push origin "v$NEW_VERSION"
print_success "Pushed to GitHub"

# Create GitHub release
print_section "ğŸš€ Creating GitHub Release"
print_info "Creating release on GitHub..."

# Format release notes for GitHub
GITHUB_RELEASE_NOTES="$RELEASE_NOTES

---

## Installation

\`\`\`bash
# Via Claude Code plugin
/plugin marketplace add zerobearing2/rails-ai
/plugin install rails-ai
\`\`\`

## What's Changed

See [CHANGELOG.md](https://github.com/zerobearing2/rails-ai/blob/master/CHANGELOG.md) for full details.

**Full Changelog**: https://github.com/zerobearing2/rails-ai/compare/v$CURRENT_VERSION...v$NEW_VERSION"

gh release create "v$NEW_VERSION" \
  --title "v$NEW_VERSION" \
  --notes "$GITHUB_RELEASE_NOTES" \
  --latest

print_success "GitHub release created"

# Summary
print_section "âœ¨ Release Complete"
echo ""
echo -e "${GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
echo -e "${GREEN}â•‘     ğŸ‰ RELEASE v$NEW_VERSION COMPLETE     â•‘${NC}"
echo -e "${GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo ""
print_success "Version: $NEW_VERSION"
print_success "Tag: v$NEW_VERSION"
print_success "CHANGELOG.md updated"
print_success "Plugin version updated"
print_success "Pushed to GitHub"
print_success "GitHub release created"
echo ""
print_info "View release: https://github.com/zerobearing2/rails-ai/releases/tag/v$NEW_VERSION"
echo ""
